<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚«ãƒ«ã‚¯ï¼†ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ (FIXED)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@400;700;900&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
<style>
:root {
    --bg-color: #0a0b10;
    --panel-bg: rgba(15, 20, 30, 0.95);
    --primary-x: #00f2ff;
    --primary-o: #ff0055;
    --accent-gold: #ffd700;
    --text-color: #e0e6ed;
    --glass-border: 1px solid rgba(255, 255, 255, 0.15);
    --disabled-card: rgba(255, 255, 255, 0.1);
}

body {
    margin: 0; background: radial-gradient(circle at center, #1a1f2c 0%, #050505 100%);
    color: var(--text-color); font-family: 'Orbitron', 'Noto Sans JP', sans-serif;
    height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden;
    touch-action: manipulation; user-select: none; -webkit-user-select: none;
}

.bg-grid {
    position: absolute; width: 200%; height: 200%;
    background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
    background-size: 50px 50px; transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
    animation: gridMove 20s linear infinite; z-index: -1; pointer-events: none;
}
@keyframes gridMove { 100% { transform: perspective(500px) rotateX(60deg) translateY(50px) translateZ(-200px); } }

.app-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
.screen { position: absolute; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; }
.screen.active { display: flex; }
.panel-glass { background: var(--panel-bg); border: var(--glass-border); backdrop-filter: blur(10px); border-radius: 15px; box-shadow: 0 0 40px rgba(0,0,0,0.5); }

/* Typography */
h1 { 
    font-size: 3.5rem; line-height: 0.8; text-align: center; margin-bottom: 40px; 
    position: relative; letter-spacing: -2px;
}
h1 span { color: var(--accent-gold); text-shadow: 0 0 10px var(--accent-gold); }
.jp-title-sub {
    font-family: 'Noto Sans JP'; font-size: 0.9rem; font-weight: 900; letter-spacing: 8px;
    color: var(--primary-x); text-shadow: 0 0 8px var(--primary-x);
    margin-bottom: 8px; margin-left: 8px; text-transform: uppercase; opacity: 0.9;
}
.game-title { text-shadow: 0 0 20px rgba(0, 242, 255, 0.3); }
h2 { letter-spacing: 2px; color: #fff; text-align: center; margin-bottom: 20px; }

.menu-grid { display: grid; gap: 15px; width: 300px; text-align: center; }
.btn { 
    background: rgba(0,0,0,0.6); border: 1px solid #fff; color: #fff; padding: 15px; 
    font-family: 'Orbitron'; font-weight: bold; cursor: pointer; transition: 0.2s; 
}
.btn:hover { background: #fff; color: #000; transform: scale(1.02); }
.btn:active { transform: scale(0.98); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
.btn-local { border-color: var(--primary-x); color: var(--primary-x); }
.btn-net { border-color: var(--accent-gold); color: var(--accent-gold); }
.btn-back { border-color: #666; color: #aaa; }

/* Game Board */
.game-board { 
    width: min(100vw, 500px); height: min(100vh, 850px); 
    display: flex; flex-direction: column; 
    padding: 10px 5px; box-sizing: border-box; position: relative; 
    justify-content: space-between;
}

/* Player Area */
.player-area { 
    display: flex; flex-direction: column; gap: 5px; padding: 8px; 
    background: rgba(0,0,0,0.3); border-radius: 8px; transition: 0.3s; 
    border: 1px solid transparent; position: relative;
}
.player-area.opponent { opacity: 0.9; }

/* Inactive State for Local/Phase */
.player-area.inactive { opacity: 0.3; filter: grayscale(0.8); pointer-events: none; }

.player-area.is-attacker {
    border-color: var(--primary-o);
    background: linear-gradient(to bottom, rgba(255, 0, 85, 0.15), rgba(0,0,0,0.4));
    box-shadow: 0 0 15px rgba(255, 0, 85, 0.2);
}
.player-area.is-defender {
    border-color: var(--primary-x);
    background: linear-gradient(to bottom, rgba(0, 242, 255, 0.15), rgba(0,0,0,0.4));
    box-shadow: 0 0 15px rgba(0, 242, 255, 0.2);
}

/* Rotate Opponent in Local Mode */
.game-board.mode-local .player-area.opponent {
    transform: rotate(180deg); margin-bottom: 5px;
}

.p-info { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; }
.role-badge { font-size: 0.8rem; padding: 3px 6px; border-radius: 4px; font-weight: bold; }
.is-attacker .role-badge { background: var(--primary-o); color: #fff; }
.is-defender .role-badge { background: var(--primary-x); color: #000; }

/* Cards & Chips */
.cards-container { display: flex; justify-content: center; gap: 6px; min-height: 65px; flex-wrap: wrap; align-items: center; transition: 0.3s; }
.chips-container { display: flex; justify-content: center; gap: 8px; min-height: 35px; margin-bottom: 4px; }

.card {
    width: 48px; height: 64px; background: #000; border: 2px solid #555; color: #fff;
    display: flex; justify-content: center; align-items: center; font-size: 1.6rem; font-weight: bold;
    border-radius: 6px; cursor: pointer; transition: 0.2s; position: relative;
}
.card:active { transform: scale(0.9); }
.card.selected { border-color: var(--accent-gold); background: #222; box-shadow: 0 0 10px var(--accent-gold); transform: translateY(-3px); }
.card.disabled { opacity: 0.3; pointer-events: none; border-color: #333; }
.card.temp-used { opacity: 0.2; pointer-events: none; border-color: #333; background: #111; } /* è¨ˆç®—ä¸­ã«ä¸€æ™‚ä½¿ç”¨ã•ã‚ŒãŸçŠ¶æ…‹ */

/* Blind Mode for Local Privacy */
.blind .card {
    background: repeating-linear-gradient(45deg, #111, #111 5px, #222 5px, #222 10px);
    color: transparent; border-color: #444; pointer-events: none;
}

.card-back { background: repeating-linear-gradient(45deg, #111, #111 5px, #222 5px, #222 10px); color: transparent; border-color: #444; }

.chip {
    width: 32px; height: 32px; border-radius: 50%; background: #222; border: 1px solid #666;
    display: flex; justify-content: center; align-items: center; font-family: monospace; font-size: 1.2rem;
    cursor: pointer; transition: 0.2s;
}
.chip.selected { background: var(--accent-gold); color: #000; box-shadow: 0 0 8px var(--accent-gold); }
.chip.used { opacity: 0.2; pointer-events: none; }
.chip.temp-used { opacity: 0.2; pointer-events: none; border-color: #333; }

/* Battle Field */
.battle-field { 
    flex-grow: 1; display: flex; flex-direction: column; 
    justify-content: center; align-items: center; gap: 15px; position: relative; 
}
.card-slot { 
    width: 55px; height: 75px; border: 2px dashed #444; border-radius: 8px; 
    display: flex; justify-content: center; align-items: center; transition: 0.3s; 
}
.card-slot .card { width: 100%; height: 100%; cursor: default; border: none; }

.center-info { display: flex; flex-direction: column; align-items: center; gap: 2px; z-index: 5; }
#turn-indicator { font-size: 0.7rem; color: #666; letter-spacing: 2px; }
#timer-display { font-size: 2.2rem; font-weight: bold; font-family: 'Orbitron'; color: #fff; text-shadow: 0 0 10px #fff; line-height: 1; }
#timer-display.warning { color: var(--primary-o); animation: blink 0.5s infinite alternate; }
@keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }

/* Calc Zone */
.calc-zone { 
    position: absolute; left: 50%; transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.95); border: 2px solid var(--accent-gold); border-radius: 10px;
    padding: 10px; width: 90%; max-width: 320px; box-sizing: border-box; 
    display: flex; flex-direction: column; gap: 8px; z-index: 50;
    box-shadow: 0 0 30px rgba(0,0,0,0.8); transition: all 0.3s;
}
.calc-zone.hidden { display: none; }

/* Positions */
.calc-pos-p1 { bottom: 5px; top: auto; transform: translateX(-50%); }
.calc-pos-p2 { top: 5px; bottom: auto; transform: translateX(-50%) rotate(180deg); }

.calc-header { text-align: center; color: var(--accent-gold); font-size: 0.8rem; font-family: 'Orbitron'; }
.calc-screen { 
    background: #111; color: var(--accent-gold); font-family: 'Roboto Mono'; font-size: 1.4rem; 
    padding: 8px; border-radius: 4px; min-height: 1.5em; border: 1px solid #333; text-align: right; overflow: hidden;
}
.calc-controls { display: flex; gap: 5px; }
.btn-calc-action { flex: 1; padding: 12px 5px; border: none; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; border-radius: 4px; font-size: 0.9rem; }
.btn-fire { background: var(--primary-o); color: #fff; }
.btn-pass { background: #333; color: #aaa; }
.btn-clear { background: #444; color: #fff; }

#game-status { text-align: center; color: var(--accent-gold); font-size: 0.85rem; margin: 5px 0; min-height: 1.2em; text-shadow: 0 0 5px rgba(0,0,0,0.8); }
#btn-abort { position: absolute; bottom: 5px; right: 5px; font-size: 0.7rem; background: transparent; border: 1px solid #444; color: #666; cursor: pointer; padding: 5px 10px; z-index: 10; }

.overlay { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); display:none; flex-direction:column; justify-content:center; align-items:center; z-index: 100; }
.rules-box { background: #1a1f2c; padding: 20px; border: 1px solid #444; max-width: 90%; color: #ddd; border-radius: 10px; }
.room-input { background: #000; border: 1px solid #555; color: #fff; padding: 10px; font-family: 'Orbitron'; text-align: center; width: 100%; box-sizing: border-box; }
.id-box { background: #000; color: var(--primary-x); padding: 10px; border: 1px dashed #555; margin: 10px 0; font-family: monospace; }
.sys-msg { color: #888; font-size: 0.8rem; margin-bottom: 5px; }
.blink { animation: blinkText 1s infinite alternate; }
@keyframes blinkText { from { opacity: 0.5; } to { opacity: 1; } }

@media (max-width: 600px) {
    .game-board { height: 100vh; width: 100vw; border-radius: 0; padding: 2px; }
    .card { width: 55px; height: 75px; font-size: 2rem; }
    .chip { width: 40px; height: 40px; font-size: 1.5rem; }
    .player-area { padding: 5px; gap: 2px; }
    .battle-field { padding: 10px 0; gap: 5px; }
    #timer-display { font-size: 2rem; }
}
    
/* QRã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒªã‚¢ï¼ˆç™½èƒŒæ™¯å¿…é ˆï¼‰ */
#qrcode-display {
    background: #fff;
    padding: 10px;
    border-radius: 8px;
    margin: 10px auto;
    width: 128px; /* QRã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹ */
    height: 128px;
}
/* QRã‚³ãƒ¼ãƒ‰ç”»åƒãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã« */
#qrcode-display img { display: block; }

/* ã‚«ãƒ¡ãƒ©èª­ã¿å–ã‚Šã‚¨ãƒªã‚¢ */
#qr-reader {
    width: 100%;
    max-width: 300px;
    margin: 10px auto;
    border: 1px solid var(--primary-x);
    display: none; /* åˆæœŸã¯éè¡¨ç¤º */
}
</style>
</head>
<body>

<div class="bg-grid"></div>

<div class="app-container">
    
    <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
    <div id="screen-title" class="screen active panel-glass">
       <h1 class="game-title">
            <div class="jp-title-sub">ã‚«ãƒ«ã‚¯ ï¼† ã‚¯ãƒ©ãƒƒã‚·ãƒ¥</div>
            CALC &<br><span>CRASH</span>
        </h1>
        <div class="menu-grid">
            <button class="btn btn-local" onclick="GameApp.initLocal()">ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ (2P)</button>
            <button class="btn btn-net" onclick="Network.openMenu()">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦</button>
            <button class="btn btn-rules" onclick="document.getElementById('rules-overlay').style.display='flex'">ãƒ«ãƒ¼ãƒ«ç¢ºèª</button>
        </div>
        <div style="margin-top:20px; font-size:0.7rem; color:#555;">FIX VERSION</div>
    </div>

    <!-- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
<div id="screen-network" class="screen panel-glass">
    <h2>NETWORK SYSTEM</h2>
    
    <!-- åˆæœŸãƒ¡ãƒ‹ãƒ¥ãƒ¼ (GUESTå´ã«ãƒœã‚¿ãƒ³ã¨ãƒªãƒ¼ãƒ€ãƒ¼ã‚’è¿½åŠ ) -->
    <div id="net-init" class="menu-grid">
        <button class="btn btn-net" onclick="Network.initHost()">ãƒ«ãƒ¼ãƒ ä½œæˆ (HOST)</button>
        <div class="divider">ã¾ãŸã¯</div>
        
        <!-- è¿½åŠ : ã‚«ãƒ¡ãƒ©èª­ã¿å–ã‚Šã‚¨ãƒªã‚¢ -->
        <div id="qr-reader"></div>
        
        <!-- å¤‰æ›´: IDå…¥åŠ›æ¬„ã®æ¨ªã¾ãŸã¯ä¸Šã«ã‚¹ã‚­ãƒ£ãƒ³ãƒœã‚¿ãƒ³é…ç½® -->
        <div style="display:flex; gap:5px;">
            <input type="text" id="net-id-input" class="room-input" placeholder="HOST ID">
            <button class="btn btn-local" onclick="Network.startScanner()" style="padding:10px;">ğŸ“·</button>
        </div>

        <button class="btn btn-net" onclick="Network.joinRoom()">ãƒ«ãƒ¼ãƒ å‚åŠ  (GUEST)</button>
        <button class="btn btn-back" onclick="Network.closeMenu()">æˆ»ã‚‹</button>
    </div>

    <!-- HOSTç”»é¢ (QRè¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¿½åŠ ) -->
    <div id="net-host" class="menu-grid" style="display:none;">
        <p class="sys-msg">ä»¥ä¸‹ã®IDã‚’å…±æœ‰ã€ã¾ãŸã¯QRã‚’ã‚¹ã‚­ãƒ£ãƒ³</p>
        
        <!-- è¿½åŠ : QRã‚³ãƒ¼ãƒ‰è¡¨ç¤ºç”¨ -->
        <div id="qrcode-display"></div>
        
        <div id="host-id-display" class="id-box">GENERATING...</div>
        <div class="blink">æ¥ç¶šå¾…ã¡...</div>
        <button class="btn btn-back" onclick="location.reload()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>

    <div id="net-connect" class="menu-grid" style="display:none;">
        <div class="blink" style="color:var(--primary-x)">æ¥ç¶šä¸­...</div>
    </div>
</div>

    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="screen-game" class="screen">
        <div id="game-board" class="game-board panel-glass">
            
            <!-- ä¸Šéƒ¨ã‚¨ãƒªã‚¢ (P2) -->
            <div id="area-p2" class="player-area opponent">
                <div class="p-info">
                    <span id="p2-role" class="role-badge">DEFENDER</span>
                    <span class="p-name">PLAYER 2</span>
                </div>
                <div class="chips-container" id="p2-chips"></div>
                <div class="cards-container" id="p2-hand"></div>
            </div>

            <!-- ãƒ¡ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ -->
            <div class="battle-field">
                <div class="card-slot" id="slot-p2">
                    <div class="card card-placeholder">WAIT</div>
                </div>
                
                <div class="center-info">
                    <div id="turn-indicator">TURN 1</div>
                    <div id="timer-display">15</div>
                </div>

                <div class="card-slot" id="slot-p1">
                    <div class="card card-placeholder">PLACE</div>
                </div>

                <!-- è¨ˆç®—å¼æ§‹ç¯‰ã‚¨ãƒªã‚¢ -->
                <div id="calc-zone" class="calc-zone hidden">
                    <div class="calc-header">TARGET: <span id="calc-target-num" style="color:#fff; font-size:1.2em;">?</span></div>
                    <div class="calc-screen" id="calc-display"></div>
                    <div class="calc-controls">
                        <button class="btn-calc-action btn-clear" onclick="GameApp.clearEquation()">CLEAR</button>
                        <button class="btn-calc-action btn-fire" onclick="GameApp.submitEquation()">BREAK!</button>
                        <button class="btn-calc-action btn-pass" onclick="GameApp.passTurn()">PASS</button>
                    </div>
                </div>
            </div>

            <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ -->
            <div id="game-status">ã‚²ãƒ¼ãƒ é–‹å§‹</div>

            <!-- ä¸‹éƒ¨ã‚¨ãƒªã‚¢ (P1) -->
            <div id="area-p1" class="player-area self">
                <div class="chips-container" id="p1-chips"></div>
                <div class="cards-container" id="p1-hand"></div>
                <div class="p-info">
                    <span class="p-name">PLAYER 1 <span class="you-tag" id="you-badge">YOU</span></span>
                    <span id="p1-role" class="role-badge attacker">ATTACKER</span>
                </div>
            </div>

            <!-- æ’¤é€€ãƒœã‚¿ãƒ³ -->
            <button id="btn-abort" onclick="GameApp.toTitle()">TITLE</button>
        </div>

        <!-- ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ (ãƒªã‚¶ãƒ«ãƒˆãƒ»å†æˆ¦) -->
        <div id="overlay" class="overlay">
            <h2 id="overlay-msg">WINNER</h2>
            <div id="rematch-area" class="menu-grid" style="width: 250px;">
                <div id="rematch-status" style="text-align:center; font-size:0.8rem; color:#aaa; height: 1.5em;"></div>
                <button id="btn-rematch" class="btn btn-net" onclick="GameApp.requestRematch()">å†æˆ¦ã™ã‚‹</button>
                <button class="btn btn-back" onclick="GameApp.toTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- ãƒ«ãƒ¼ãƒ«èª¬æ˜ -->
    <div id="rules-overlay" class="overlay" style="display:none; z-index:100;">
        <div class="rules-box">
            <h3>RULES</h3>
            <p>1. <strong>CRASH (æ•°å­—ä¸€è‡´)</strong>: ä¸¡è€…ã‚«ãƒ¼ãƒ‰ã‚’æ¨ã¦ã‚‹ã€‚</p>
            <p>2. <strong>æ•°å­—ä¸ä¸€è‡´</strong>: æ”»ã‚(Attacker)ãŒè¨ˆç®—ã€‚</p>
            <ul style="text-align:left; font-size:0.8rem; color:#aaa;">
                <li><strong>æˆåŠŸ (BREAK)</strong>: ç›¸æ‰‹ã®æ•°å­—ã‚’ä½œã‚‹ã€‚<br>ä½¿ç”¨ã—ãŸã‚«ãƒ¼ãƒ‰ã¯å…¨ã¦ç ´æ£„ã€‚ç›¸æ‰‹ã‚‚ç ´æ£„ã€‚<br>â€»ç­”ãˆã¯æ•´æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</li>
                <li><strong>å¤±æ•— (GUARD)</strong>: è¨ˆç®—ä¸å¯/PASSã€‚<br>æ”»ã‚ã®ã‚«ãƒ¼ãƒ‰ã¯æˆ»ã‚‹ã€‚å®ˆã‚Šã®ã‚«ãƒ¼ãƒ‰ã¯ç ´æ£„ã€‚</li>
            </ul>
            <p>3. å…ˆã«æ‰‹æœ­ãŒãªããªã£ãŸæ–¹ã®å‹åˆ©ã€‚</p>
            <button class="btn" onclick="document.getElementById('rules-overlay').style.display='none'">CLOSE</button>
        </div>
    </div>

</div>

<script>
/* FIX LOG:
   1. Added tempHand/tempChips to prevent infinite card usage in equations.
   2. Added 'blind' class for local multiplayer privacy.
   3. Fixed Division/Math logic (Integer check, Zero Division).
   4. Improved Rematch synchronization logic.
*/

const AudioSys = {
    ctx: null,
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if(this.ctx.state === 'suspended') this.ctx.resume(); },
    play(type) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const t = this.ctx.currentTime;
        if (type === 'select') {
            osc.frequency.setValueAtTime(800, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.start(); osc.stop(t + 0.1);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(); osc.stop(t + 0.3);
        } else if (type === 'break') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, t);
            osc.frequency.setValueAtTime(880, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.4);
            osc.start(); osc.stop(t + 0.4);
        } else if (type === 'timer') {
            osc.frequency.setValueAtTime(1000, t);
            gain.gain.setValueAtTime(0.05, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.05);
            osc.start(); osc.stop(t + 0.05);
        }
    }
};

const Network = {
    peer: null, conn: null, isHost: false, html5QrcodeScanner: null, // scannerå¤‰æ•°ã‚’è¿½åŠ 

    openMenu() {
        AudioSys.init();
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById('screen-network').classList.add('active');
        document.getElementById('net-init').style.display = 'grid';
        document.getElementById('net-host').style.display = 'none';
        document.getElementById('net-connect').style.display = 'none';
        
        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ããŸã³ã«ã‚¹ã‚­ãƒ£ãƒŠè¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ
        document.getElementById('qr-reader').style.display = 'none';
    },

    closeMenu() {
        this.stopScanner(); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹ã¨ãã¯ã‚«ãƒ¡ãƒ©ã‚‚åœæ­¢
        if(this.peer) { this.peer.destroy(); this.peer = null; }
        document.getElementById('screen-network').classList.remove('active');
        document.getElementById('screen-title').classList.add('active');
    },

    // HOSTåˆæœŸåŒ–ï¼ˆQRç”Ÿæˆã‚’è¿½åŠ ï¼‰
    initHost() {
        AudioSys.init();
        document.getElementById('net-init').style.display = 'none';
        document.getElementById('net-host').style.display = 'grid';
        
        this.peer = new Peer();
        this.peer.on('open', id => {
            document.getElementById('host-id-display').innerText = id;
            this.isHost = true;

            // --- è¿½åŠ : QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ ---
            const qrBox = document.getElementById("qrcode-display");
            qrBox.innerHTML = ""; // å‰å›ã®æ®‹ã‚Šã‚’ã‚¯ãƒªã‚¢
            new QRCode(qrBox, {
                text: id,
                width: 128,
                height: 128
            });
            // ------------------------
        });

        this.peer.on('connection', c => {
            this.conn = c;
            this.setupConn();
            GameApp.initOnline(true);
        });
    },

    // è¿½åŠ : QRã‚¹ã‚­ãƒ£ãƒŠãƒ¼èµ·å‹•
    startScanner() {
        const readerElem = document.getElementById('qr-reader');
        // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        if (readerElem.style.display === 'block') {
            this.stopScanner();
            return;
        }
        readerElem.style.display = 'block';

        this.html5QrcodeScanner = new Html5QrcodeScanner(
            "qr-reader", { fps: 10, qrbox: 200 }
        );

        this.html5QrcodeScanner.render(
            (decodedText) => {
                // æˆåŠŸæ™‚
                document.getElementById('net-id-input').value = decodedText;
                AudioSys.play('select');
                this.stopScanner(); // èª­ã¿å–ã‚ŒãŸã‚‰ã‚«ãƒ¡ãƒ©åœæ­¢
                // ãã®ã¾ã¾è‡ªå‹•å‚åŠ ã—ãŸã‘ã‚Œã° this.joinRoom(); ã‚’å‘¼ã¶
            },
            (errorMessage) => {
                // èª­ã¿å–ã‚Šå¤±æ•—ã¯ç„¡è¦–ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°æŠ‘åˆ¶ã®ãŸã‚ä½•ã‚‚ã—ãªã„ï¼‰
            }
        );
    },

    // è¿½åŠ : ã‚¹ã‚­ãƒ£ãƒŠãƒ¼åœæ­¢
    stopScanner() {
        if (this.html5QrcodeScanner) {
            this.html5QrcodeScanner.clear().catch(error => console.error(error));
            this.html5QrcodeScanner = null;
        }
        document.getElementById('qr-reader').style.display = 'none';
    },

    joinRoom() {
        this.stopScanner(); // å¿µã®ãŸã‚åœæ­¢
        const id = document.getElementById('net-id-input').value;
        if(!id) return alert("IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        
        AudioSys.init();
        document.getElementById('net-init').style.display = 'none';
        document.getElementById('net-connect').style.display = 'grid';
        
        this.peer = new Peer();
        this.peer.on('open', () => {
            this.conn = this.peer.connect(id);
            this.isHost = false;
            this.setupConn();
        });
        this.peer.on('error', () => { alert("æ¥ç¶šå¤±æ•—"); location.reload(); });
    },

    setupConn() {
        this.conn.on('open', () => {
            if(!this.isHost) GameApp.initOnline(false);
        });
        this.conn.on('data', data => GameApp.handleNetworkData(data));
        this.conn.on('close', () => { alert("é€šä¿¡åˆ‡æ–­"); GameApp.toTitle(); });
    },
    send(type, payload) {
        if(this.conn && this.conn.open) this.conn.send({type, payload});
    }
};

const GameApp = {
    mode: 'local', role: null, turn: 1, attacker: 'p1', phase: 'select',
    players: {
        p1: { hand: [1,2,3,5,7,9], chips: ['+','-','*','/'], selection: null },
        p2: { hand: [1,2,3,5,7,9], chips: ['+','-','*','/'], selection: null }
    },
    // ä¸€æ™‚ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ç®¡ç† (Fix 1)
    tempState: { hand: [], chips: [] }, 
    calcBuffer: [], timer: 15, timerInterval: null, isResolving: false,
    rematchState: { me: false, opp: false },

    initLocal() { 
        AudioSys.init();
        this.mode = 'local'; 
        this.role = 'p1'; 
        document.getElementById('game-board').classList.add('mode-local');
        document.getElementById('you-badge').style.display = 'none';
        this.startGame(); 
    },
    initOnline(isHost) { 
        this.mode = 'online'; 
        this.role = isHost ? 'p1' : 'p2'; 
        document.getElementById('game-board').classList.remove('mode-local');
        document.getElementById('you-badge').style.display = 'inline';
        this.startGame(); 
    },
    
    startGame() {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById('screen-game').classList.add('active');
        this.resetGameData();
    },

    resetGameData() {
        this.turn = 1;
        this.attacker = (Math.random() > 0.5) ? 'p1' : 'p2';
        this.isResolving = false;
        this.rematchState = { me: false, opp: false };
        
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('rematch-status').innerText = "";
        document.getElementById('btn-rematch').disabled = false;
        document.getElementById('btn-rematch').innerText = "å†æˆ¦ã™ã‚‹";

        if(this.mode === 'online' && Network.isHost) {
            Network.send('start_info', { attacker: this.attacker });
        }
        
        ['p1','p2'].forEach(p => {
            this.players[p].hand = [1,2,3,5,7,9];
            this.players[p].chips = ['+','-','*','/'];
            this.players[p].selection = null;
        });
        
        this.renderUI();
        this.startPhase('select');
    },

    startPhase(p) {
        this.phase = p;
        this.stopTimer();
        this.isResolving = false;
        
        const calcZone = document.getElementById('calc-zone');
        calcZone.classList.add('hidden'); 

        // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
        document.getElementById('area-p1').classList.remove('inactive');
        document.getElementById('area-p2').classList.remove('inactive');
        document.getElementById('p1-hand').classList.remove('blind');
        document.getElementById('p2-hand').classList.remove('blind');

        if (p === 'select') {
            this.players.p1.selection = null;
            this.players.p2.selection = null;
            document.getElementById('slot-p1').innerHTML = '<div class="card card-placeholder">PLACE</div>';
            document.getElementById('slot-p2').innerHTML = '<div class="card card-placeholder">WAIT</div>';
            
            this.setStatus(`PHASE 1: ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠ (æ®‹ã‚Š15ç§’)`);
            this.startTimer(15, () => this.autoSelect());

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸè¡¨ç¤ºåˆ¶å¾¡
            if(this.mode === 'local') {
                this.renderUI(); // åˆæœŸãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰é©ç”¨ã®ãŸã‚
            }

        } else if (p === 'reveal') {
            this.revealCards();
        } else if (p === 'calc') {
            this.calcBuffer = [];
            // ä¸€æ™‚ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ– (Fix 1)
            const activePlayer = (this.mode === 'local' && this.attacker === 'p2') ? 'p2' : this.role;
            if(this.isMyTurnToCalc()) {
                this.tempState.hand = [...this.players[activePlayer].hand];
                this.tempState.chips = [...this.players[activePlayer].chips];
                
                // å ´ã«å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã¯è¨ˆç®—ã«ä½¿ãˆãªã„ã®ã§tempStateã‹ã‚‰ã‚‚é™¤å»
                // ãŸã ã—ã€Œå ´ã«å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã€è‡ªä½“ã‚’æ•°å¼ã®æœ€åˆã«ä½¿ã†ãƒ«ãƒ¼ãƒ«
                // ã“ã“ã§ã¯ã€Œå ´ã«å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã€ã¯æ•°å¼ã®å§‹ç‚¹ã¨ã—ã¦è‡ªå‹•è¿½åŠ ã•ã‚Œã€æ‰‹æœ­æ¶ˆè²»ã‹ã‚‰ã¯é™¤å¤–æ¸ˆã¿ã¨ã™ã‚‹
                // å®Ÿè£…: å ´ã«å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­é…åˆ—ã‹ã‚‰æ¢ã—ã¦tempã‹ã‚‰æ¶ˆã™
                const playedCard = this.players[activePlayer].selection;
                const idx = this.tempState.hand.indexOf(playedCard);
                if(idx > -1) this.tempState.hand.splice(idx, 1);
            }

            this.renderEquation();
            
            const target = (this.attacker === 'p1') ? this.players.p2.selection : this.players.p1.selection;
            document.getElementById('calc-target-num').innerText = target;

            calcZone.classList.remove('calc-pos-p1', 'calc-pos-p2', 'hidden');
            
            if (this.mode === 'local' && this.attacker === 'p2') {
                calcZone.classList.add('calc-pos-p2');
            } else {
                calcZone.classList.add('calc-pos-p1');
            }

            if (this.isMyTurnToCalc()) {
                const myPlayed = (this.mode === 'local' && this.attacker === 'p2') ? this.players.p2.selection : this.players[this.role].selection;
                // åˆæœŸå€¤ã¨ã—ã¦è‡ªåˆ†ã®å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã‚’ã‚»ãƒƒãƒˆ
                this.addToEquation({type:'number', value:myPlayed, from:'field'}, true);
                this.setStatus(`PHASE 2: è¨ˆç®—ã—ã¦ãã ã•ã„ (æ®‹ã‚Š30ç§’)`);
                this.startTimer(30, () => this.passTurn());
            } else {
                this.setStatus(`PHASE 2: ç›¸æ‰‹ã®è¨ˆç®—å¾…ã¡...`);
                if (this.mode === 'online') calcZone.classList.add('hidden');
                this.startTimer(30, null); 
            }
        }
        this.renderUI();
    },

    startTimer(sec, callback) {
        this.timer = sec;
        const disp = document.getElementById('timer-display');
        disp.innerText = this.timer;
        disp.classList.remove('warning');
        if(this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
            this.timer--;
            disp.innerText = this.timer;
            if (this.timer <= 5) { disp.classList.add('warning'); AudioSys.play('timer'); }
            if (this.timer <= 0) {
                this.stopTimer();
                if (callback && (this.mode === 'local' || this.isMyAction())) callback();
            }
        }, 1000);
    },
    stopTimer() { if(this.timerInterval) clearInterval(this.timerInterval); },

    selectCard(playerKey, val) {
        if (this.phase !== 'select') return;
        
        if (this.mode === 'local') {
             if (this.players.p1.selection === null && playerKey === 'p1') {
                 this.players.p1.selection = val;
                 this.setStatus("P1å®Œäº†ã€‚P2é¸æŠä¸­...");
                 AudioSys.play('select');
             } else if (this.players.p2.selection === null && playerKey === 'p2') {
                 this.players.p2.selection = val;
                 if(this.players.p1.selection === null) {
                    this.setStatus("P2å®Œäº†ã€‚P1é¸æŠä¸­...");
                 }
                 AudioSys.play('select');
             }
             
             if(this.players.p1.selection !== null && this.players.p2.selection !== null) {
                 this.startPhase('reveal');
             } else {
                 this.renderUI();
             }
             return;
        }

        // Online logic
        if (playerKey !== this.role) return;
        this.players[this.role].selection = val;
        Network.send('selected', { value: val });
        this.setStatus("ç›¸æ‰‹ã®é¸æŠã‚’å¾…ã£ã¦ã„ã¾ã™...");
        this.renderUI();
        const opp = (this.role === 'p1') ? 'p2' : 'p1';
        if (this.players[opp].selection !== null) this.startPhase('reveal');
    },

    autoSelect() {
        if (this.mode === 'local') {
            if(this.players.p1.selection === null) this.players.p1.selection = this.players.p1.hand[0];
            if(this.players.p2.selection === null) this.players.p2.selection = this.players.p2.hand[0];
            this.startPhase('reveal');
        } else {
            if (this.players[this.role].selection === null) this.selectCard(this.role, this.players[this.role].hand[0]);
        }
    },

    revealCards() {
        const p1Val = this.players.p1.selection;
        const p2Val = this.players.p2.selection;
        document.getElementById('slot-p1').innerHTML = `<div class="card selected">${p1Val}</div>`;
        document.getElementById('slot-p2').innerHTML = `<div class="card selected">${p2Val}</div>`;
        
        // UIæ›´æ–°ï¼ˆãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰è§£é™¤ï¼‰
        document.getElementById('p1-hand').classList.remove('blind');
        document.getElementById('p2-hand').classList.remove('blind');
        document.getElementById('area-p1').classList.remove('inactive');
        document.getElementById('area-p2').classList.remove('inactive');

        setTimeout(() => {
            if (p1Val === p2Val) {
                AudioSys.play('crash');
                this.setStatus("CRASH!! æ•°å­—ãŒä¸€è‡´ï¼");
                setTimeout(() => this.resolveRound('crash'), 2000);
            } else {
                this.startPhase('calc');
            }
        }, 1000);
    },

    addToEquation(item, isInit = false) {
        if (!this.isMyTurnToCalc()) return;

        // Fix 1: Check availability in tempState
        if (!isInit) {
            if (item.type === 'number') {
                const idx = this.tempState.hand.indexOf(item.value);
                if (idx === -1) return; // æŒã£ã¦ã„ãªã„ï¼ˆä½¿ç”¨æ¸ˆã¿ï¼‰ãªã‚‰è¿½åŠ ä¸å¯
                this.tempState.hand.splice(idx, 1);
            } else if (item.type === 'operator') {
                const idx = this.tempState.chips.indexOf(item.value);
                if (idx === -1) return;
                this.tempState.chips.splice(idx, 1);
            }
        }

        this.calcBuffer.push(item);
        this.renderEquation();
        this.renderUI(); // æ‰‹æœ­ã®ä½¿ç”¨çŠ¶æ…‹ã‚’æ›´æ–°
        if(!isInit) AudioSys.play('select');
    },

    clearEquation() {
        if (!this.isMyTurnToCalc()) return;
        this.calcBuffer = [];
        // Restore tempState
        const activePlayer = (this.mode === 'local' && this.attacker === 'p2') ? 'p2' : this.role;
        this.tempState.hand = [...this.players[activePlayer].hand];
        this.tempState.chips = [...this.players[activePlayer].chips];
        
        const myPlayed = this.players[activePlayer].selection;
        const idx = this.tempState.hand.indexOf(myPlayed);
        if(idx > -1) this.tempState.hand.splice(idx, 1);

        // Re-add initial
        this.addToEquation({type:'number', value:myPlayed, from:'field'}, true);
        this.renderUI();
    },

    submitEquation() {
        if (!this.isMyTurnToCalc()) return;
        const target = (this.attacker === 'p1') ? this.players.p2.selection : this.players.p1.selection;
        let expr = "";
        
        // å¼ã®æ§‹ç¯‰
        for (let item of this.calcBuffer) {
            if (item.type === 'number') expr += item.value;
            else expr += item.value;
        }

        try {
            // Fix 3: å®‰å…¨ãªè¨ˆç®—
            if (expr.includes('/0')) throw new Error("ZeroDiv"); // å˜ç´”ãªã‚¼ãƒ­é™¤ç®—ãƒã‚§ãƒƒã‚¯
            
            // Functionã§ã®è¨ˆç®—å®Ÿè¡Œï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã€å…¥åŠ›ã¯åˆ¶å¾¡ã•ã‚ŒãŸãƒœã‚¿ãƒ³ã®ã¿ãªã®ã§è¨±å®¹ï¼‰
            const result = Function('"use strict";return (' + expr + ')')();
            
            if (!isFinite(result) || isNaN(result)) {
                 this.setStatus("ç„¡åŠ¹ãªè¨ˆç®—çµæœã§ã™");
                 return;
            }

            // æ•´æ•°ã‹ã¤ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è‡´ãƒã‚§ãƒƒã‚¯
            if (result === target) {
                AudioSys.play('break');
                this.setStatus("BREAK SUCCESS! æ•°å¼æˆç«‹ï¼");
                if (this.mode === 'online') Network.send('break', { buffer: this.calcBuffer });
                setTimeout(() => this.resolveRound('break'), 1500);
            } else {
                this.setStatus(`ä¸ä¸€è‡´: ${Math.round(result*100)/100} != ${target}`);
            }
        } catch (e) { 
            this.setStatus("ç„¡åŠ¹ãªæ•°å¼ã§ã™"); 
        }
    },

    passTurn() {
        if (!this.isMyTurnToCalc()) return;
        this.setStatus("GUARDED... è¨ˆç®—ã‚’è«¦ã‚ã¾ã—ãŸ");
        if (this.mode === 'online') Network.send('guard', {});
        setTimeout(() => this.resolveRound('guard'), 1500);
    },

    resolveRound(type) {
        if(this.isResolving) return;
        this.isResolving = true;
        
        if (type === 'crash') {
            this.discardCard('p1', this.players.p1.selection);
            this.discardCard('p2', this.players.p2.selection);
        } else if (type === 'break') {
            const att = this.attacker;
            const def = (att === 'p1') ? 'p2' : 'p1';
            this.discardCard(att, this.players[att].selection);
            this.discardCard(def, this.players[def].selection);
            // ãƒãƒƒãƒ•ã‚¡ã«ã‚ã‚‹ä½¿ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰/ãƒãƒƒãƒ—ã‚’å‰Šé™¤
            this.applyBufferCosts(att);
        } else if (type === 'guard') {
            const def = (this.attacker === 'p1') ? 'p2' : 'p1';
            this.discardCard(def, this.players[def].selection);
        }
        this.checkWinCondition();
    },

    applyBufferCosts(playerKey) {
        // Fix 1: tempStateã§ã¯ãªãå®Ÿéš›ã®ãƒãƒ³ãƒ‰ã‚’æ¸›ã‚‰ã™
        // calcBufferã«ã¯ {from: 'hand'/'chip'} ãŒã‚ã‚‹ã¯ãšã ãŒã€
        // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å—ä¿¡æ™‚ã«ã‚‚æ•´åˆæ€§ã‚’ä¿ã¤ãŸã‚ã€å€¤ãƒ™ãƒ¼ã‚¹ã§å‰Šé™¤ã™ã‚‹
        
        // fieldã®ã‚«ãƒ¼ãƒ‰ã¯æ—¢ã«discardCardã§å‡¦ç†ã•ã‚Œã¦ã„ã‚‹ã®ã§ç„¡è¦–
        for (let i = 1; i < this.calcBuffer.length; i++) {
            const item = this.calcBuffer[i];
            if (item.type === 'number' && item.from === 'hand') {
                const idx = this.players[playerKey].hand.indexOf(item.value);
                if (idx !== -1) this.players[playerKey].hand.splice(idx, 1);
            } else if (item.type === 'operator') {
                const idx = this.players[playerKey].chips.indexOf(item.value);
                if (idx !== -1) this.players[playerKey].chips.splice(idx, 1);
            }
        }
    },
    discardCard(playerKey, val) {
        const idx = this.players[playerKey].hand.indexOf(val);
        if (idx !== -1) this.players[playerKey].hand.splice(idx, 1);
    },

    checkWinCondition() {
        const p1Win = this.players.p1.hand.length === 0;
        const p2Win = this.players.p2.hand.length === 0;
        
        if (p1Win && p2Win) this.gameOver("DRAW");
        else if (p1Win) this.gameOver("PLAYER 1 WINS");
        else if (p2Win) this.gameOver("PLAYER 2 WINS");
        else {
            this.turn++;
            this.attacker = (this.attacker === 'p1') ? 'p2' : 'p1';
            this.startPhase('select');
        }
    },
    
    gameOver(msg) {
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('overlay-msg').innerText = msg;
        
        const btnRematch = document.getElementById('btn-rematch');
        if (this.mode === 'online') {
            btnRematch.style.display = 'block';
        } else {
            btnRematch.style.display = 'none';
        }
    },

    // --- Rematch Logic (Fix 4) ---
    requestRematch() {
        if(this.mode !== 'online') return;
        AudioSys.init();
        this.rematchState.me = true;
        document.getElementById('btn-rematch').innerText = "æ‰¿èªå¾…ã¡...";
        document.getElementById('btn-rematch').disabled = true;
        
        if (this.rematchState.opp) {
            document.getElementById('rematch-status').innerText = "å¯¾æˆ¦ã‚’é–‹å§‹ã—ã¾ã™...";
        } else {
            document.getElementById('rematch-status').innerText = "ç›¸æ‰‹ã®å¿œç­”ã‚’å¾…ã£ã¦ã„ã¾ã™...";
        }
        
        Network.send('rematch_req', {});
        this.checkRematchStart();
    },

    checkRematchStart() {
        // ãƒ›ã‚¹ãƒˆãƒ»ã‚²ã‚¹ãƒˆå•ã‚ãšã€ä¸¡è€…ãŒTrueãªã‚‰ãƒªã‚»ãƒƒãƒˆã‚’å®Ÿè¡Œ
        // ãŸã ã—ãƒ›ã‚¹ãƒˆãŒã‚¤ãƒ‹ã‚·ã‚¢ãƒãƒ–ã‚’ã¨ã£ã¦start_infoã‚’é€ã‚‹
        if (this.rematchState.me && this.rematchState.opp) {
            if (Network.isHost) {
                setTimeout(() => this.resetGameData(), 1000);
            }
        }
    },

    toTitle() {
        this.stopTimer();
        if (this.mode === 'online') {
            if (Network.peer) { Network.peer.destroy(); Network.peer = null; }
            Network.conn = null;
            Network.isHost = false;
        }
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('screen-title').classList.add('active');
        document.getElementById('game-board').classList.remove('mode-local');
    },

    renderUI() {
        const self = this.role;
        const opp = (self === 'p1') ? 'p2' : 'p1';
        
        document.getElementById('turn-indicator').innerText = `TURN ${this.turn}`;

        const p1Area = document.getElementById('area-p1');
        const p2Area = document.getElementById('area-p2');
        const isP1Attacker = (this.attacker === 'p1');
        
        p1Area.className = `player-area self ${isP1Attacker ? 'is-attacker' : 'is-defender'}`;
        document.getElementById('p1-role').innerText = isP1Attacker ? 'ATTACKER' : 'DEFENDER';
        
        p2Area.className = `player-area opponent ${!isP1Attacker ? 'is-attacker' : 'is-defender'}`;
        document.getElementById('p2-role').innerText = !isP1Attacker ? 'ATTACKER' : 'DEFENDER';

        // Local Mode Privacy (Fix 2)
        if (this.mode === 'local' && this.phase === 'select') {
            if (this.players.p1.selection === null) {
                // P1 Turn
                p1Area.classList.remove('inactive');
                p2Area.classList.add('inactive');
                document.getElementById('p2-hand').classList.add('blind');
                document.getElementById('p1-hand').classList.remove('blind');
            } else if (this.players.p2.selection === null) {
                // P2 Turn
                p1Area.classList.add('inactive');
                p2Area.classList.remove('inactive');
                document.getElementById('p1-hand').classList.add('blind');
                document.getElementById('p2-hand').classList.remove('blind');
            }
        }

        this.renderHand(self, 'p1-hand', 'p1-chips');
        this.renderHand(opp, 'p2-hand', 'p2-chips');
        
        if (this.phase === 'select') {
             const p1Sel = this.players[self].selection;
             const p2Sel = this.players[opp].selection;
             document.getElementById('slot-p1').innerHTML = p1Sel ? `<div class="card card-back">âœ”</div>` : `<div class="card card-placeholder">YOU</div>`;
             document.getElementById('slot-p2').innerHTML = p2Sel ? `<div class="card card-back">âœ”</div>` : `<div class="card card-placeholder">OPP</div>`;
        }
    },

    renderHand(playerKey, handId, chipsId) {
        const p = this.players[playerKey];
        const canControl = (this.mode === 'local') ? true : (playerKey === this.role);
        
        // Calcãƒ•ã‚§ãƒ¼ã‚ºã§ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å ´åˆã€ä¸€æ™‚çš„ãªæ‰‹æœ­çŠ¶æ³ã‚’å‚ç…§ã—ã¦è¡¨ç¤ºã‚’åˆ¶å¾¡ã™ã‚‹
        let tempHandCounts = {};
        let tempChipCounts = {};
        
        if(this.phase === 'calc' && this.isMyTurnToCalc()) {
             // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãªã‚‰tempStateã‹ã‚‰æ®‹æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
             const activeKey = (this.mode === 'local' && this.attacker === 'p2') ? 'p2' : this.role;
             if(playerKey === activeKey) {
                 this.tempState.hand.forEach(x => tempHandCounts[x] = (tempHandCounts[x]||0)+1);
                 this.tempState.chips.forEach(x => tempChipCounts[x] = (tempChipCounts[x]||0)+1);
             }
        }

        const hContainer = document.getElementById(handId);
        const cContainer = document.getElementById(chipsId);
        
        hContainer.innerHTML = '';
        // æ‰‹æœ­ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        // æ³¨æ„: å˜ç´”ãƒ«ãƒ¼ãƒ—ã ã¨åŒã˜æ•°å­—ãŒè¤‡æ•°ã‚ã‚‹å ´åˆã®å‡¦ç†ãŒé›£ã—ã„ã®ã§ã€
        // ã€ŒæŒã£ã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã€ã‚’ã™ã¹ã¦æç”»ã—ã€tempStateã«ãªã„åˆ†ã‚’disabledã«ã™ã‚‹
        
        // tempStateãƒã‚§ãƒƒã‚¯ç”¨ã‚³ãƒ”ãƒ¼
        let currentHandCheck = (this.phase === 'calc' && this.isMyTurnToCalc() && 
                               ((this.mode === 'local' && this.attacker === playerKey) || 
                                (this.mode === 'online' && playerKey === this.role))) 
                                ? [...this.tempState.hand] : null;

        p.hand.forEach(val => {
            const div = document.createElement('div');
            div.className = 'card';
            div.innerText = val;
            
            let isAvailable = true;

            if (this.phase === 'select' && canControl) {
                 // é¸æŠãƒ•ã‚§ãƒ¼ã‚º
                 const alreadySelected = (this.mode === 'local') ? (this.players[playerKey].selection !== null) : (p.selection !== null);
                 if (alreadySelected) {
                     div.classList.add('disabled');
                     isAvailable = false;
                 } else {
                     div.onclick = () => this.selectCard(playerKey, val);
                 }
            } else if (this.phase === 'calc' && canControl && this.attacker === playerKey) {
                 // è¨ˆç®—ãƒ•ã‚§ãƒ¼ã‚º (Fix 1: tempStateã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯)
                 const idx = currentHandCheck ? currentHandCheck.indexOf(val) : -1;
                 if (idx !== -1) {
                     // ä½¿ç”¨å¯èƒ½
                     currentHandCheck.splice(idx, 1); // 1ã¤æ¶ˆè²»
                     div.onclick = () => this.addToEquation({type:'number', value:val, from:'hand'});
                 } else {
                     // ä½¿ç”¨æ¸ˆã¿
                     div.classList.add('temp-used');
                     isAvailable = false;
                 }
            } else {
                div.classList.add('disabled');
                isAvailable = false;
            }
            hContainer.appendChild(div);
        });

        cContainer.innerHTML = '';
        const allChips = ['+','-','*','/'];
        
        // ãƒãƒƒãƒ—ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆåŒæ§˜ã«tempStateãƒã‚§ãƒƒã‚¯ï¼‰
        let currentChipCheck = (this.phase === 'calc' && this.isMyTurnToCalc() && 
                               ((this.mode === 'local' && this.attacker === playerKey) || 
                                (this.mode === 'online' && playerKey === this.role))) 
                                ? [...this.tempState.chips] : null;

        allChips.forEach(op => {
            const div = document.createElement('div');
            div.className = 'chip';
            div.innerText = op;
            
            // ãã‚‚ãã‚‚æ‰€æŒã—ã¦ã„ã‚‹ã‹
            const totalCount = p.chips.filter(x => x === op).length;
            if (totalCount === 0) {
                div.classList.add('used');
            } else {
                if (this.phase === 'calc' && canControl && this.attacker === playerKey) {
                    const idx = currentChipCheck ? currentChipCheck.indexOf(op) : -1;
                    if(idx !== -1) {
                         currentChipCheck.splice(idx, 1);
                         div.onclick = () => this.addToEquation({type:'operator', value:op});
                    } else {
                        div.classList.add('temp-used');
                    }
                } else {
                    // è¨ˆç®—ãƒ•ã‚§ãƒ¼ã‚ºä»¥å¤–ã¯è§¦ã‚Œãªã„
                    // div.classList.add('disabled'); // chipã«ã¯disabledã‚¹ã‚¿ã‚¤ãƒ«ãŒãªã„ãŒã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãªã—ã§OK
                }
            }
            cContainer.appendChild(div);
        });
    },

    renderEquation() {
        const disp = document.getElementById('calc-display');
        disp.innerHTML = '';
        this.calcBuffer.forEach(item => {
            const span = document.createElement('span');
            span.innerText = item.value + " ";
            disp.appendChild(span);
        });
    },

    setStatus(msg) { document.getElementById('game-status').innerText = msg; },

    isMyAction() {
        if (this.mode === 'local') return true;
        if (this.phase === 'select') return this.players[this.role].selection === null;
        if (this.phase === 'calc') return this.attacker === this.role;
        return false;
    },
    isMyTurnToCalc() {
        if (this.phase !== 'calc') return false;
        if (this.mode === 'local') return true; 
        return this.attacker === this.role;
    },

    handleNetworkData(data) {
        const type = data.type;
        const pl = data.payload;
        if (type === 'start_info') { 
            this.attacker = pl.attacker;
            this.resetGameData(); 
        } 
        else if (type === 'selected') {
            const opp = (this.role === 'p1') ? 'p2' : 'p1';
            this.players[opp].selection = pl.value;
            this.renderUI();
            if (this.players[this.role].selection !== null) this.startPhase('reveal');
        }
        else if (type === 'break') {
            this.calcBuffer = pl.buffer;
            this.setStatus("ç›¸æ‰‹ãŒè¨ˆç®—ã‚’æˆåŠŸã•ã›ã¾ã—ãŸï¼");
            const oppRole = (this.role === 'p1') ? 'p2' : 'p1';
            this.applyBufferCosts(oppRole); 
            setTimeout(() => this.resolveRound('break'), 1500);
        }
        else if (type === 'guard') {
            this.setStatus("ç›¸æ‰‹ãŒè¨ˆç®—ã‚’è«¦ã‚ã¾ã—ãŸ");
            setTimeout(() => this.resolveRound('guard'), 1500);
        }
        else if (type === 'rematch_req') {
            this.rematchState.opp = true;
            document.getElementById('rematch-status').innerText = "ç›¸æ‰‹ãŒå†æˆ¦ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™ï¼";
            if(this.rematchState.me) {
                 // è‡ªåˆ†ã‚‚å¸Œæœ›æ¸ˆã¿ãªã‚‰ãƒ›ã‚¹ãƒˆã‚’å¾…ã¤ï¼ˆã‚ã‚‹ã„ã¯è‡ªåˆ†ãŒãƒ›ã‚¹ãƒˆãªã‚‰é–‹å§‹ï¼‰
                 this.checkRematchStart();
            }
        }
    }
};
</script>
</body>
</html>
